
//
// execute:
//  - python testdrive.py
//
// %%VARIABLE%% will be replaced with consts by python code
//
// author: minu jeong
//


#version 430

#define X %%X%%
#define Y %%Y%%
#define Z %%Z%%
#define W %%W%%
#define H %%H%%

layout(local_size_x=X, local_size_y=Y, local_size_z=Z) in;
layout (std430, binding=0) buffer in_0
{
    vec4 inxs[1];
};

layout (std430, binding=1) buffer out_0
{
    vec4 outxs[1];
};

layout (std430, binding=2) buffer uv_0
{
    vec2 uvs[1];
};

#define win_width 3
#define win_height 3
#define win_wh 49
#define median_i 25
float window[win_wh] = {
    // should manually initialize this
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0
};

void main()
{
    // define consts
    const int x = int(gl_LocalInvocationID.x);
    const int y = int(gl_WorkGroupID.x);
    const int frag_i = x + y * W;

    // read window
    for (int win_x = -win_width; win_x <= win_width; win_x++)
    {
        for (int win_y = -win_height; win_y <= win_height; win_y++)
        {
            int win_i = win_y * W + win_x;
            int src_i = frag_i + win_i;

            if (win_i < 0 || win_i >= win_wh)
            {
                window[win_i] = inxs[frag_i].x;
                continue;
            }

            window[win_i] = inxs[src_i].x;
        }
    }

    // simple bubble sort to find median
    float sum = 0.0;
    while(true)
    {
        sum = 0.0;
        bool is_swapped = false;
        for (int win_ii = win_wh - 1; win_ii > 1; win_ii--)
        {
            float now = window[win_ii];
            sum += now;

            if (window[win_ii - 1] > now)
            {
                // swap
                window[win_ii] = window[win_ii - 1];
                window[win_ii - 1] = now;
                is_swapped = true;
            }
        }

        if (!is_swapped)
        {
            break;
        }
    }
    float median = window[median_i];

    // return to buffer
    float r = inxs[frag_i].x;
    float g = r;
    float b = r;
    float a = 1.0;
    outxs[frag_i] = vec4(r, g, b, a);
}
